
def generateBitSequence(numBits):
    poly = Poly([1, 0, 0, 1, 1])
    startState = [1, 0, 0, 0]

    result = lfsr(poly, startState, numBits)
    asChars = list(map(str, result))

    return asChars

def lfsr(poly, startState, numBits):
    """
        Outputs a sequence with N elements. Each element is
        derived from successive values of the LFSR sequence
        generated by polynomial P and initial state S. Polynomial
        P is represented by a list of coefficients in decreasing
        power order.
        :param numBits: number of bits to generate
        :param startState: the starting state of the lfsr (array of ints)
        :param poly: the polynomial to be used (Poly class or array of ints)
    """
    def lfsr_internal():
        """
            Generates linear sequence according to polynomial
            P and initial state S.
        """
        seq, state = [startState[-1]], startState
        for j in range(2 ** len(startState) - 2):
            st0 = sum([i * j for i, j in zip(state, poly[1:])]) % 2
            state = [st0] + state[:-1]
            seq += [state[-1]]
        return seq

    assert len(poly) > 1 and len(poly) - 1 == len(startState)

    s = lfsr_internal()
    L = len(s)

    return [s[i % L] for i in range(numBits)]


class Poly(list):
    """
        A class for polynomials. The coefficients are
        stored as a list [c0, c1, ... , c_m] where the polynomial
        is c0*x**m + c1*x**(m-1) + ... + c{m-1}*x + c_m.

        Class provides a means of printing the stored list

        For example:
        Poly([1,0,1,0]) => x^3 + x^1
    """
    def __str__(self):
        L = [" x^%s " % (k,) for (k, x) in enumerate(self[::-1]) if x == 1 and k != 0]
        L.reverse()
        return "+".join(L) + "+ " + str(self.__getitem__(self.__len__() - 1))



"""
	TODO
		List of maximum length polynomials (can use poly class) -- maybe can generate them
		Find out / figure out how many bits to generate each time
"""